\documentclass[a4paper,12pt]{report}
\usepackage[margin=1in]{geometry} % to change the page dimensions
\usepackage{ctex}
\usepackage{xeCJK}
\usepackage{comment}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{times}
\usepackage{setspace}
% \usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{graphicx}
%\graphicspath{{fig/}}
\usepackage{wrapfig}
\usepackage{subfigure}
\usepackage{array}  
% \usepackage{fontspec,xunicode,xltxtra}
% \renewcommand{\sfdefault}{cmr}
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage[titletoc]{appendix}
%\usepackage[top=30mm,bottom=30mm,left=20mm,right=20mm]{geometry}
%\usepackage{cite}
\usepackage[backend = biber, style = gb7714-2015, defernumbers=true]{biblatex}
\renewcommand*{\bibfont}{\small}
\addbibresource{reference.bib}
%\usepackage{courier}
\setmonofont{Courier New}
\usepackage{listings}
\lstset{tabsize=4, keepspaces=true,
    xleftmargin=2em,xrightmargin=0em, aboveskip=1em,
    %backgroundcolor=\color{gray!20},  % 定义背景颜色
    frame=none,                       % 表示不要边框
    extendedchars=false,              % 解决代码跨页时，章节标题，页眉等汉字不显示的问题
    numberstyle=\ttfamily,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\bfseries,
    breakindent=10pt,
    identifierstyle=,                 % nothing happens
    commentstyle=\color{green}\small,  % 注释的设置
    morecomment=[l][\color{green}]{\#},
    numbers=left,stepnumber=1,numberstyle=\scriptsize,
    showstringspaces=false,
    showspaces=false,
    flexiblecolumns=true,
    breaklines=true, breakautoindent=true,breakindent=4em,
    escapeinside={/*@}{@*/},
}
\usepackage{amsmath}
\usepackage{amsthm}
\newtheorem{theorem}{定理}
\newtheorem{definition}{定义}
\newtheorem{corollary}{推论}
\newtheorem{example}{例}
\usepackage{amsfonts}
%\usepackage{bm}
\usepackage{booktabs} % for much better looking tables
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfigure} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...
\usepackage{cases} %equation set
\usepackage{multirow} %use table
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{hyperref}
\hypersetup{colorlinks,linkcolor=black,anchorcolor=black,citecolor=black, pdfstartview=FitH,bookmarksnumbered=true,bookmarksopen=true,} % set href in tex & pdf
%\usepackage[framed,numbered,autolinebreaks,useliterate]{mcode} % 插入matlab代码
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt

\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
   \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
       {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
       \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
       \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
       \fi
       \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
   \end{center}
  }
\makeatother
%%%%此处break 算法
%---------------------------------------------------------------------
%	页眉页脚设置
%---------------------------------------------------------------------
\fancypagestyle{plain}{
    \pagestyle{fancy}      %改变章节首页页眉
}

\pagestyle{fancy}
\lhead{\kaishu~数据挖掘实验报告~}
%\rhead{\kaishu~xxx}
\cfoot{\thepage}
\titleformat{\chapter}{\centering\zihao{2}\heiti}{第\chinese{chapter}章}{1em}{}
% \titleformat{\chapter*}{\centering\zihao{-1}\heiti}
\begin{comment}
%---------------------------------------------------------------------
%	章节标题设置
%---------------------------------------------------------------------
\titleformat{\chapter}{\centering\zihao{-1}\heiti}{实验\chinese{chapter}}{1em}{}
\titlespacing{\chapter}{0pt}{*0}{*6}
\end{comment}
%---------------------------------------------------------------------
%	摘要标题设置
%---------------------------------------------------------------------
%\renewcommand{\abstractname}{摘要}
\renewcommand{\figurename}{图}
\renewcommand{\tablename}{表}

%---------------------------------------------------------------------
%	参考文献设置
%---------------------------------------------------------------------
%\renewcommand{\bibname}{\zihao{2}{\hspace{\fill}参\hspace{0.5em}考\hspace{0.5em}文\hspace{0.5em}献\hspace{\fill}}}
\renewcommand{\bibname}{参考文献}
\begin{comment}
%---------------------------------------------------------------------
%	引用文献设置为上标
%---------------------------------------------------------------------
\makeatletter
\def\@cite#1#2{\textsuperscript{[{#1\if@tempswa , #2\fi}]}}
\makeatother
\end{comment}
%---------------------------------------------------------------------
%	目录页设置
%---------------------------------------------------------------------
%\renewcommand{\contentsname}{\zihao{-3} 目\quad 录}
\renewcommand{\contentsname}{目录}
\titlecontents{chapter}[0em]{\songti\zihao{-4}}{\thecontentslabel\ }{}
{\hspace{.5em}\titlerule*[4pt]{$\cdot$}\contentspage}
\titlecontents{section}[2em]{\vspace{0.1\baselineskip}\songti\zihao{-4}}{\thecontentslabel\ }{}
{\hspace{.5em}\titlerule*[4pt]{$\cdot$}\contentspage}
\titlecontents{subsection}[4em]{\vspace{0.1\baselineskip}\songti\zihao{-4}}{\thecontentslabel\ }{}
{\hspace{.5em}\titlerule*[4pt]{$\cdot$}\contentspage}

\begin{document}
%---------------------------------------------------------------------
%	封面设置
%---------------------------------------------------------------------
\begin{titlepage}
    \begin{center}
        
    \includegraphics[width=0.60\textwidth]{nk_logo.pdf}\\
    \vspace{10mm}
    \hspace*{\fill} \\
    \textbf{\zihao{1}{数据挖掘实验报告}}\\
    \vspace{\fill}
    
\setlength{\extrarowheight}{3mm}
{\songti\zihao{3}	
\begin{tabular}{rl}
    
    {\makebox[4\ccwd][s]{学\qquad 号：\qquad 2\ 2\ 1\ 3\ 1\ 1\ 7}} & ~\kaishu   \\
    {\makebox[4\ccwd][s]{姓\qquad 名：\qquad 蔡\quad 佳\quad 良}} & ~\kaishu   \\
    {\makebox[4\ccwd][s]{年\qquad 级：\qquad 2\ 0\ 2\ 2\quad 级}} & ~\kaishu   \\
    {\makebox[4\ccwd][s]{学\qquad 院：\qquad 统计与数据科学学院}} & ~\kaishu   \\
    {\makebox[4\ccwd][s]{专\qquad 业：\qquad 统\quad 计\quad 学}} & ~\kaishu   \\
    %{\makebox[4\ccwd][s]{授课教师：}}  & ~\kaishu xxx~教授\\ 
    %{\makebox[4\ccwd][s]{课程助教：}} & ~\kaishu xxx~xxx \\
    {\makebox[4\ccwd][s]{完成日期：}}  & ~\kaishu\quad2\ 0\ 2\ 4年\ 1\ 1月\ 1\ 7日\\ 

\end{tabular}
 }\\[2cm]
%\vspace{\fill}
%\zihao{4}
%使用\LaTeX 撰写于\today
    \end{center}	
\end{titlepage}

%---------------------------------------------------------------------
%  摘要页
%---------------------------------------------------------------------


%---------------------------------------------------------------------
%  目录页
%---------------------------------------------------------------------
\tableofcontents % 生成目录

%---------------------------------------------------------------------
%  绪论
%---------------------------------------------------------------------
\chapter{第一次上机实验(提取图像的纹理特征)}
\section{实验要求}
\begin{itemize}
    \item 给定若干张图像，利用灰度共生矩阵特征或局部二值模式特征对这些图像进行特征提取
    \item 图象是W * H * 3的矩阵
    \item 将最终提取到的特征通过plot的形式展示，直观对比不同纹理提取到的特征
    \item 使用Python编程实现
\end{itemize}
\section{数据分析与处理}
\par 将图像转化为灰度矩阵
\section{实验步骤与原理}
\subsection{灰度共生矩阵}
灰度共生矩阵是从$N\times N$的图像$f(x,y)$的灰度为$i$的像素出发，统计与距离为$\delta=(\mathrm{d}x^{2}+\mathrm{d}y^{2})^{1/2}$，灰度为$j$的像素同时出现的概率为,数学表达式为：$$P(i,j,\delta,\theta)=\left\{[(x,y),(x+\mathrm{d}x,y+\mathrm{d}y)]|f(x,y)=i,f(x+\mathrm{d}x,y+\mathrm{d}y)=j\right\}$$
分别考虑$\theta=0^{\circ},45^{\circ},90^{\circ},135^{\circ}$，
\par 当$\theta=0^{\circ}$时，$\mathrm{d}x=1,\mathrm{d}y=0$；
\par 当$\theta=45^{\circ}$时，$\mathrm{d}x=1,\mathrm{d}y=-1$；
\par 当$\theta=90^{\circ}$时，$\mathrm{d}x=0,\mathrm{d}y=-1$；
\par 当$\theta=135^{\circ}$时，$\mathrm{d}x=-1,\mathrm{d}y=-1$。
\subsection{局部二值模式}
LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息（例如亮点和暗点），数学表达式为：$$LBP=\sum_{p=0}^{P−1} s(g_p−g_c)\cdot 2^p,$$其中，

\begin{itemize}
    \item $s(x)$是符号函数：$$s(x)=\left\{ \begin{array}{rcl}1\quad x\ge 0\\0\quad x<0\end{array}\right.$$
    \item P 是邻域像素数（通常为 8）
\end{itemize}
\section{实验结果与分析}
\par 通过两种方法下生成的\href{https://github.com/psa1K/Data_mining_2024/tree/main/datasets/exp1/output}{特征图}可以看出，两类图有明显不同的纹理特征。
\section{实验代码}
\begin{lstlisting}[language=Python]
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from PIL import Image, ImageDraw, ImageFont

mpl.rcParams["font.sans-serif"] = ["SimHei"]  # 中文
plt.rcParams["axes.unicode_minus"] = False  # 正负号

# 更改当前工作目录为脚本所在目录
os.chdir(os.path.dirname(os.path.abspath(__file__)))  
c_path = "./cloud/"
f_path = "./forest/"

os.makedirs("./output/glcm/", exist_ok=True)  # 创建输出文件夹
os.makedirs("./output/lbp/", exist_ok=True)

c_name = [c_path + i for i in os.listdir(c_path)]
f_name = [f_path + i for i in os.listdir(f_path)]

def show_grey(root=c_name):
    for n, i in enumerate(c_name):
        plt.subplot(2, 5, n + 1)
        img = Image.open(i)
        img = img.convert("L")  # 转为灰度图
        plt.imshow(img, cmap="gray")  # 显示灰度图
        plt.axis("off")  # 不显示坐标轴
    plt.show()

def get_mat(root):
    for n, i in enumerate(root):
        # plt.subplot(2, 5, n + 1)
        img = Image.open(i)
        img = img.convert("L")  # 转为灰度图
        img = np.array(img)  # 转为ndarray
        yield i, img

# 计算灰度共生矩阵(gray-level co-occurrence matrix)
def get_glcm(img, angle=0, distance=1, gray_levels=256):
    # 归一化到0-gray_levels灰度级
    img = (img / (np.max(img) + 1e-5) * (gray_levels - 1)).astype(int)  
    h, w = img.shape  # 获取图像的尺寸
    glcm = np.zeros((gray_levels, gray_levels), dtype=np.int64)

    for i in range(h):
        for j in range(w):
            match angle:
                case 0:
                    if j + distance < w:
                        glcm[img[i, j], img[i, j + distance]] += 1
                case 90:
                    if i + distance < h:
                        glcm[img[i, j], img[i + distance, j]] += 1
                case 45:
                    if i + distance < h and j + distance < w:
                        glcm[img[i, j], img[i + distance, j + distance]] += 1
                case 135:
                    if i + distance < h and j - distance >= 0:
                        glcm[img[i, j], img[i + distance, j - distance]] += 1

    glcm = glcm / np.sum(glcm)  # 归一化
    return glcm

# 绘制灰度共生矩阵
def get_glcm_fig(root, angles=[0, 90, 45, 135]):
    for i, img in get_mat(root):
        glcms = []  # 存储各角度的 GLCM 图像
        for angle in angles:
            glcm = get_glcm(img, angle=angle)
            glcm = (glcm / glcm.max() * 255).astype(np.uint8)
            glcms.append((Image.fromarray(glcm), f"Angle: {angle}°"))  # 保存图像和标题

        # 计算单张 GLCM 图像的大小
        width, height = glcms[0][0].size
        title_height = 20  # 为标题预留的高度

        # 2x2 布局，标题增加额外空间
        canvas = Image.new("L", (2 * width, 2 * (height + title_height)), "white")

        draw = ImageDraw.Draw(canvas)
        font = ImageFont.load_default()

        for idx, (glcm, title) in enumerate(glcms):
            x_offset = (idx % 2) * width
            y_offset = (idx // 2) * (height + title_height)

            text_bbox = draw.textbbox((0, 0), title, font=font)
            text_width = text_bbox[2] - text_bbox[0]
            text_x = x_offset + (width - text_width) // 2
            draw.text((text_x, y_offset), title, fill="black", font=font)

            canvas.paste(glcm, (x_offset, y_offset + title_height))

        canvas.save(f"./output/glcm/{i}")

# 计算局部二值模式(local binary pattern)
def get_lbp(img):
    h, w = img.shape  # 获取图像的尺寸
    lbp = np.zeros((h - 2, w - 2), dtype=np.int64)  # 忽略边缘像素
    for i in range(1, h - 1):
        for j in range(1, w - 1):
            center = img[i, j]
            neighbors = [
                img[i, j - 1],
                img[i + 1, j - 1],
                img[i + 1, j],
                img[i + 1, j + 1],
                img[i, j + 1],
                img[i - 1, j + 1],
                img[i - 1, j],
                img[i - 1, j - 1],
            ]
            code = 0
            for idx, neighbor in enumerate(neighbors):
                if neighbor > center:
                    code += 2**idx
            lbp[i - 1, j - 1] = code
    return lbp


# 绘制局部二值模式
def get_lbp_fig(root):
    for i, img in get_mat(root):
        lbp = get_lbp(img)
        Image.fromarray(lbp.astype(np.uint8)).save(f"./output/lbp/{i}")

def main():
    roots = [c_name, f_name]
    for root in roots:
        get_glcm_fig(root)
        get_lbp_fig(root)

if __name__ == "__main__":
    main()

\end{lstlisting}
\clearpage
\chapter{第二次上机实验}
\section{实验要求}
\section{数据分析与处理}
\section{实验步骤与原理}
\section{实验结论与分析}
\section{实验代码}
\clearpage
\chapter{第三次上机实验}
\section{实验要求}
\section{数据分析与处理}
\section{实验步骤与原理}
\section{实验结论与分析}
\section{实验代码}
\clearpage
\chapter{第四次上机实验}
\section{实验要求}
\section{数据分析与处理}
\section{实验步骤与原理}
\section{实验结论与分析}
\section{实验代码}
\clearpage
\chapter{第五次上机实验}
\section{实验要求}
\section{数据分析与处理}
\section{实验步骤与原理}
\section{实验结论与分析}
\section{实验代码}
\printbibliography

\end{document}